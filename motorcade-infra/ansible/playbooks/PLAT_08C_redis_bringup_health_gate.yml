---
# PLAT_08C â€” Redis bring-up (authoritative)
# Fix6: stop churn by (1) removing journald logging entirely via full unit rewrite,
#       (2) preflighting volume ownership + SELinux labels,
#       (3) bounded readiness that asserts container is Up before ping.
#
# Run:
#   cd ~/Repos/motorcade-infra/ansible
#   ansible-playbook -i inventories/prod/hosts.ini playbooks/PLAT_08C_redis_bringup_health_gate.yml --ask-vault-pass

- name: PLAT_08C | Redis bring-up + bounded readiness (unit rewrite + perms/SELinux)
  hosts: motorcade-web-01
  become: true
  gather_facts: true

  vars:
    podman_bin: /usr/local/bin/podman

    platform_target: motorcade-platform.target

    redis_container: motorcade-redis
    redis_service: motorcade-redis.service
    old_ready_service: motorcade-redis-ready.service

    redis_image: docker.io/library/redis:7.2-alpine
    redis_network: motorcade-core

    motorcade_root: /srv/motorcade
    redis_volume_host: "{{ motorcade_root }}/volumes/redis"
    redis_data_container: /data

    redis_user_uid: 999
    redis_user_gid: 999

    redis_appendonly: "yes"
    redis_save_rules: "60 1000"

    # bounded wait (~60s)
    wait_retries: 30
    wait_delay: 2

    redis_unit_file: /etc/systemd/system/motorcade-redis.service

  tasks:
    - name: Preflight | Ensure podman exists at locked path
      ansible.builtin.stat:
        path: "{{ podman_bin }}"
      register: podman_stat

    - name: Preflight | Fail if podman missing
      ansible.builtin.fail:
        msg: "Podman not found at {{ podman_bin }}. Fix PLAT_01B first."
      when: not podman_stat.stat.exists

    - name: Preflight | Mask old readiness gate unit (prevents hang loops)
      ansible.builtin.systemd:
        name: "{{ old_ready_service }}"
        state: stopped
        enabled: false
        masked: true
      failed_when: false

    - name: Filesystem | Ensure redis volume directory exists (UID/GID 999)
      ansible.builtin.file:
        path: "{{ redis_volume_host }}"
        state: directory
        owner: "{{ redis_user_uid }}"
        group: "{{ redis_user_gid }}"
        mode: "0755"

    - name: SELinux | Detect enforcing mode (best-effort)
      ansible.builtin.command: getenforce
      register: selinux_mode
      changed_when: false
      failed_when: false

    - name: SELinux | Check for semanage availability
      ansible.builtin.command: bash -lc 'command -v semanage >/dev/null 2>&1'
      register: semanage_present
      changed_when: false
      failed_when: false
      when:
        - selinux_mode.stdout is defined
        - selinux_mode.stdout | trim == 'Enforcing'

    - name: SELinux | Set fcontext + restorecon for redis volume (preferred)
      ansible.builtin.shell: |
        set -euo pipefail
        semanage fcontext -a -t container_file_t '{{ redis_volume_host }}(/.*)?' || true
        restorecon -Rv '{{ redis_volume_host }}'
      args:
        executable: /bin/bash
      when:
        - selinux_mode.stdout is defined
        - selinux_mode.stdout | trim == 'Enforcing'
        - semanage_present.rc == 0

    - name: SELinux | Apply chcon label for redis volume (fallback)
      ansible.builtin.command: "chcon -Rt container_file_t {{ redis_volume_host }}"
      when:
        - selinux_mode.stdout is defined
        - selinux_mode.stdout | trim == 'Enforcing'
        - semanage_present.rc != 0
      failed_when: false

    - name: Systemd | Write redis unit from scratch (NO journald)
      ansible.builtin.copy:
        dest: "{{ redis_unit_file }}"
        owner: root
        group: root
        mode: "0644"
        content: |
          [Unit]
          Description=Motorcade Redis (internal queue/cache) - authoritative
          After=network-online.target
          Wants=network-online.target
          Requires={{ platform_target }}

          [Service]
          Type=simple
          ExecStartPre=-{{ podman_bin }} rm -f {{ redis_container }}
          ExecStart={{ podman_bin }} run --name {{ redis_container }} \
            --network {{ redis_network }} \
            --user {{ redis_user_uid }}:{{ redis_user_gid }} \
            -v {{ redis_volume_host }}:{{ redis_data_container }}:Z \
            {{ redis_image }} \
            redis-server --appendonly {{ redis_appendonly }} --save "{{ redis_save_rules }}"
          ExecStop={{ podman_bin }} stop -t 10 {{ redis_container }}
          ExecStopPost=-{{ podman_bin }} rm -f {{ redis_container }}
          Restart=on-failure
          RestartSec=3

          [Install]
          WantedBy={{ platform_target }}

    - name: Systemd | Reload daemon
      ansible.builtin.systemd:
        daemon_reload: true

    - name: Systemd | Restart redis service (authoritative bring-up)
      ansible.builtin.systemd:
        name: "{{ redis_service }}"
        state: restarted
        enabled: true

    - name: Health | Wait for container to be Up (bounded)
      ansible.builtin.command: "{{ podman_bin }} ps --filter name={{ redis_container }} --format {{'"'}}{{'{{'}}.Status{{'}}'}}{{'"'}}"
      register: redis_ps
      changed_when: false
      retries: "{{ wait_retries }}"
      delay: "{{ wait_delay }}"
      until: redis_ps.rc == 0 and ('Up' in redis_ps.stdout)

    - name: Health | Wait for redis to answer PING (bounded)
      ansible.builtin.command: "{{ podman_bin }} exec {{ redis_container }} redis-cli ping"
      register: redis_ping
      changed_when: false
      retries: "{{ wait_retries }}"
      delay: "{{ wait_delay }}"
      until: redis_ping.rc == 0 and (redis_ping.stdout | trim) == 'PONG'

    - name: Verify | Success summary
      ansible.builtin.debug:
        msg:
          - "Redis is Up and responding: {{ redis_ping.stdout | trim }}"
          - "Volume: {{ redis_volume_host }} owned by {{ redis_user_uid }}:{{ redis_user_gid }}"
          - "SELinux: {{ (selinux_mode.stdout | trim) if (selinux_mode.stdout is defined) else 'unknown' }}"
